<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>abasm</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 50em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<!-- omit in toc -->
<h1 id="abasm-manual-del-usuario">ABASM: MANUAL DEL USUARIO</h1>
<p><strong>Un ensamblador en Python para los Amstrad CPC</strong></p>
<ul>
<li><a href="#introducción">Introducción</a>
<ul>
<li><a href="#por-qué-otro-ensamblador-para-amstrad">¿Por qué otro
ensamblador para Amstrad?</a></li>
</ul></li>
<li><a href="#cómo-se-usa">Cómo se usa</a>
<ul>
<li><a href="#opciones-disponibles">Opciones disponibles</a></li>
<li><a href="#ejemplos-de-uso">Ejemplos de uso</a></li>
<li><a href="#creación-de-un-proyecto-usando-asmprj">Creación de un
proyecto usando ASMPRJ</a></li>
</ul></li>
<li><a href="#productos-del-ensamblado">Productos del ensamblado</a>
<ul>
<li><a href="#el-archivo-binario">El archivo binario</a></li>
<li><a href="#listado-del-programa">Listado del programa</a></li>
<li><a href="#archivo-de-símbolos">Archivo de símbolos</a></li>
</ul></li>
<li><a href="#sintaxis">Sintaxis</a>
<ul>
<li><a href="#comentarios">Comentarios</a></li>
<li><a href="#etiquetas">Etiquetas</a></li>
<li><a href="#instrucciones">Instrucciones</a></li>
<li><a href="#bibliotecas">Bibliotecas</a></li>
<li><a href="#directivas-del-ensamblador">Directivas del Ensamblador</a>
<ul>
<li><a href="#align">ALIGN</a></li>
<li><a href="#assert">ASSERT</a></li>
<li><a href="#db-dm-defb-defm">DB, DM, DEFB, DEFM</a></li>
<li><a href="#ds-defs-rmem">DS, DEFS, RMEM</a></li>
<li><a href="#dw-defw">DW, DEFW</a></li>
<li><a href="#equ">EQU</a></li>
<li><a href="#if">IF</a></li>
<li><a href="#ifnot">IFNOT</a></li>
<li><a href="#incbin">INCBIN</a></li>
<li><a href="#macro">MACRO</a></li>
<li><a href="#let">LET</a></li>
<li><a href="#limit">LIMIT</a></li>
<li><a href="#read">READ</a></li>
<li><a href="#repeat">REPEAT</a></li>
<li><a href="#org">ORG</a></li>
<li><a href="#print">PRINT</a></li>
<li><a href="#save">SAVE</a></li>
<li><a href="#stop">STOP</a></li>
<li><a href="#while">WHILE</a></li>
</ul></li>
<li><a href="#expresiones-y-caracteres-especiales">Expresiones y
Caracteres Especiales</a></li>
</ul></li>
<li><a href="#bibliotecas-incluidas-en-abasm">Bibliotecas incluidas en
ABASM</a>
<ul>
<li><a href="#cpcrslib">CPCRSLIB</a></li>
<li><a href="#cpctelera">CPCTELERA</a></li>
</ul></li>
<li><a href="#conjunto-de-instrucciones-del-z80">Conjunto de
instrucciones del Z80</a></li>
<li><a href="#historial-de-cambios">Historial de cambios</a></li>
</ul>
<h1 id="introducción">Introducción</h1>
<p>ABASM es un ensamblador cruzado diseñado específicamente para la
plataforma Amstrad CPC y su CPU Z80. Desarrollado en Python 3, su
principal objetivo es proporcionar una herramienta ligera y altamente
portable para programadores interesados en crear código ensamblador para
esta clásica plataforma de 8 bits. Al no depender de librerías externas
ni herramientas de terceros, ABASM puede ejecutarse en cualquier sistema
que cuente con un intérprete de Python 3. Además, el proyecto incluye
otras herramientas, también programadas en Python y sin dependencias,
por ejemplo, para empaquetar el resultado del ensamblador en archivos
DSK o CDT incluye DSK.py y CDT.py. Para la creación de una estructura
básica de proyecto, incluye la herramienta ASMPRJ.py.</p>
<p>ABASM está basado en el fantástico proyecto pyZ80, creado
inicialmente por Andrew Collier y modificado posteriormente por Simon
Owen.</p>
<h2 id="por-qué-otro-ensamblador-para-amstrad">¿Por qué otro ensamblador
para Amstrad?</h2>
<p>ABASM surge de la idea de contar con una herramienta portable y fácil
de modificar por cualquiera, sin depender de sistemas operativos
específicos o entornos de desarrollo particulares. Uno de sus objetivos
es proporcionar una sintaxis compatible con el antiguo ensamblador
MAXAM, con la sintaxis de WinAPE y con la de Virtual Machine Simulator.
De esta forma, los desarrolladores pueden contar con varias opciones
para depurar su código durante el desarrollo.</p>
<p>En cualquier caso, si lo que buscas es eficiencia en vez de
portabilidad y facilidad de modificación, quizás quieras probar estos
otros ensambladores:</p>
<ul>
<li><a href="https://pasmo.speccy.org/">Pasmo</a></li>
<li><a href="https://shop-pdp.net/ashtml/">ASZ80</a></li>
<li><a href="https://github.com/EdouardBERGE/rasm">Rasm</a></li>
</ul>
<h1 id="cómo-se-usa">Cómo se usa</h1>
<p>Para ensamblar un archivo fuente de código en ensamblador (por
ejemplo, <code>program.asm</code>), basta con ejecutar el siguiente
comando:</p>
<pre><code>python3 ABASM.py &lt;program.asm&gt; [opciones]</code></pre>
<p>Este comando ensamblará el archivo <code>program.asm</code> y
generará un fichero binario con el mismo nombre,
<code>program.bin</code>.</p>
<h2 id="opciones-disponibles">Opciones disponibles</h2>
<ul>
<li><code>-d</code> o <code>--define</code>: Permite definir pares
<code>SÍMBOLO=VALOR</code>. Dichos símbolos pueden utilizarse en el
código como constantes o etiquetas. Esta opción se puede emplear
múltiples veces para definir varios símbolos.</li>
<li><code>--start</code>: Define la dirección de memoria que se tomará
como punto de inicio para la carga del programa. Por defecto, esta
dirección es <code>0x4000</code>, aunque también puede establecerse
directamente dentro del código usando la directiva
<code>ORG</code>.</li>
<li><code>-t</code> o <code>--tolerance</code>: Fija el nivel de
tolerancia ante alternativas a los opcodes soportados y ante otros
pequeños errores. WinApe es bastante laxo en la comprobación de la
sintaxis, así que puede ser necesario utilizar esta opción si se está
trabajando con código proveniente de este programa. Por defecto, su
valor es 0, el modo más estricto y menos permisivo. Los valores 1 y 2
incrementan progresivamente el nivel de tolerancia.</li>
<li><code>s</code> o <code>--sfile</code>: Genera un único fichero .s
con todo el código ensablado, incluyendo el código importado de otros
ficheros.</li>
<li><code>-o</code> o <code>--output</code>: Especifica el nombre del
archivo binario de salida. Si no se utiliza esta opción, se empleará el
nombre del archivo de entrada cambiando su extensión por
<code>.bin</code>.</li>
<li><code>-v</code> o <code>--version</code>: Muestra el número de
versión de ABASM.</li>
<li><code>--verbose</code>: Imprime mucha más información por consola
durante el proceso de ensamblado.</li>
</ul>
<h2 id="ejemplos-de-uso">Ejemplos de uso</h2>
<p>Definir una constante utilizada en el código:</p>
<pre><code>python3 ABASM.py program.asm -d MY_CONSTANT=100</code></pre>
<p>Establecer el nombre exacto del archivo binario ensamblado:</p>
<pre><code>python3 ABASM.py program.asm -o output.bin</code></pre>
<p>Establecer la dirección de inicio en memoria que debe considerarse
para el cálculo de los saltos y otras referencias relativas utilizadas
en el código fuente, por ejemplo, a <code>0x2000</code>:</p>
<pre><code>python3 ABASM.py program.asm --start 0x2000</code></pre>
<h2 id="creación-de-un-proyecto-usando-asmprj">Creación de un proyecto
usando ASMPRJ</h2>
<p>En <code>ABASM</code>, la gestión de un proyecto es sencilla. Basta
con crear un fichero principal en ensamblador que importe cualquier otro
archivo necesario mediante la directiva <code>READ</code>. Tras ejecutar
<code>ABASM</code>, se generará el fichero binario ensamblado. A
continuación, solo será necesaria una llamada adicional a las
herramientas <code>DSK</code> o <code>CDT</code> para empaquetar el
resultado y poder utilizarlo en emuladores o en hardware real (por
ejemplo, mediante dispositivos como Gotek, M4 o DDI-Revival).</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> abasm.py main.asm</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> dsk.py <span class="at">-n</span> main.dsk <span class="at">--put-bin</span> main.bin <span class="at">--start-addr</span><span class="op">=</span>0x4000 <span class="at">--load-addr</span><span class="op">=</span>0x4000</span></code></pre></div>
<p>Además, es posible generar rápidamente la estructura básica de un
proyecto utilizando la herramienta <code>ASMPRJ</code>. Esta utilidad
crea automáticamente un script de construcción con todo lo necesario
para comenzar a trabajar: en Windows se generará un fichero
<code>make.bat</code>, mientras que en Linux y macOS se creará un
fichero <code>make.sh</code>. Asimismo, se incluirá un archivo
<code>main.asm</code> con código de ejemplo listo para ser ensamblado y
probado.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">python3</span> asmprj.py <span class="at">-n</span> myproject</span></code></pre></div>
<p>Para conocer todas las opciones disponibles, se recomienda consultar
la documentación específica de <code>ASMPRJ</code>.</p>
<h1 id="productos-del-ensamblado">Productos del ensamblado</h1>
<p>Una ejecución exitosa de ABASM genera varios archivos. En esta
sección se proporciona una breve explicación de cada uno de dichos
productos.</p>
<h2 id="el-archivo-binario">El archivo binario</h2>
<p>El resultado final del proceso de ensamblado es un archivo binario
(normalmente con la extensión <code>.BIN</code>) listo para su carga en
memoria y ejecución en un Amstrad CPC. El código fuente puede dividirse
en varios archivos, pero solo uno, el principal, se pasa como parámetro
a ABASM para iniciar el ensamblado. El resto de archivos se añadirán a
medida que se referencien mediante las directivas <code>READ</code> o
<code>INCBIN</code>.</p>
<p>ABASM no genera código relocalizable, lo que significa que asume una
dirección inicial de carga en memoria. Esta dirección de carga puede
indicarse como un parámetro en la llamada a ABASM o puede establecerse
en el propio archivo principal mediante la directiva
<code>ORG</code>.</p>
<p>Por ejemplo, el siguiente código en ensamblador, que carga el valor
<code>0xFF</code> en la primera posición de la memoria de vídeo,
generaría el contenido binario que se muestra a continuación (como una
secuencia de valores en hexadecimal).</p>
<pre><code>org  0x4000       ; Fijamos la dirección inicial de carga en memoria

main:
    ld   a,0xFF       ; Cargamos en el acumulador el valor 0xFF
    ld   (0xC000),a   ; Cargamos en el primer byte de la memoria 
                      ; de vídeo el contenido de A
endloop:              ; Bucle infinito
    jp endloop        ; El valor de &#39;endloop&#39; se calculará 
                      ; según el valor inicial indicado por ORG</code></pre>
<pre><code>3E FF 32 00 C0 C3 05 40</code></pre>
<p>Dado que el Z80 es <em>little-endian</em>, podemos ver que los
últimos tres bytes son <code>C3 05 40</code>, lo que equivale a
<code>C3 4005</code>, que es el resultado en código máquina para
<code>jp endloop</code>, con <code>endloop</code> calculado a partir de
la dirección de inicio <code>0x4000</code>.</p>
<h2 id="listado-del-programa">Listado del programa</h2>
<p>Como referencia para el programador, el proceso de ensamblado también
genera un archivo con el listado del programa original y el resultado
binario de cada una de las instrucciones. La extensión de este archivo
es <code>.LST</code>.</p>
<p>Siguiendo con el ejemplo proporcionado anteriormente, el archivo
<code>.LST</code> generado tendría el siguiente contenido:</p>
<pre><code>main.asm      000001  4000                  org  0x4000
main.asm      000002  4000                  main
main.asm      000003  4000  3E FF           ld   a, 0xFF
main.asm      000004  4002  32 00 C0        ld  (0xC000), a
main.asm      000005  4005                  endloop
main.asm      000006  4005  C3 05 40        jp endloop</code></pre>
<p>El nombre del archivo origen aparece en la primera columna, mientras
que la segunda indica el número secuencial de la instrucción en dicho
archivo. La tercera columna indica qué posición de memoria ocupar el
código generado (si se ha generado alguno, ya que algunas directivas y
etiquetas no generan código binario). La cuarta columna muestra el
código binario resultante de ensamblar la instrucción y la última
columna la instrucción original.</p>
<h2 id="archivo-de-símbolos">Archivo de símbolos</h2>
<p>ABASM también genera un listado de todos los símbolos globales
encontrados y su valor asociado. La mayoría de ellos serán etiquetas
utilizadas para marcar posiciones de salto o ubicaciones de memoria
donde se han almacenado ciertos datos. Los símbolos locales son aquellos
que comienzan con el caracter ‘!’.</p>
<p>La extensión del fichero de símbolos es <code>.MAP</code> y su
formato es el de un diccionario de Python. Esto permite emplear el
archivo en otras utilidades (como los empaquetadores DSK y CDT) y
utilizar los símbolos en lugar de sus valores. En la documentación sobre
las utilidades DSK y CDT se puede encontrar un ejemplo de uso de este
archivo.</p>
<pre><code># Lista de símbolos en formato de diccionario de Python
# Símbolo: [dirección, número total de consultas (usos), nombre del archivo]
{
    &quot;ENDLOOP&quot;: [0x4005, 2, &quot;MAIN.ASM&quot;],
    &quot;MAIN&quot;: [0x4000, 1, &quot;MAIN.ASM&quot;],
}</code></pre>
<h1 id="sintaxis">Sintaxis</h1>
<p>La sintaxis de ABASM está diseñada para asemejarse lo máximo posible
a la del ensamblador MAXAM. Esta sintaxis es bastante compatible con la
soportada por el simulador WinAPE. Además, ABASM admite algunas
variaciones que también lo hacen compatible con la sintaxis utilizada
por el simulador Retro Virtual Machine. El objetivo es permitir que los
desarrolladores cuenten con varias herramientas para la depuración y
prueba de sus programas.</p>
<p>A continuación, se muestra un ejemplo sencillo de un programa escrito
utilizando la sintaxis de ABASM. Este ejemplo muestra tres de los
elementos básicos de cualquier programa escrito en ensamblador:
etiquetas, instrucciones y comentarios. Un cuarto elemento serían las
directivas del ensamblador, comandos dirigidos al propio ABASM en lugar
de al procesador. En este capítulo también repasaremos el listado
completo de las directivas soportadas.</p>
<p>Un aspecto importante y común a los cuatro elementos es que ABASM no
discrimina entre mayúsculas y minúsculas. Por lo tanto, ‘LD A,32’ y ‘ld
a,32’ producen el mismo resultado. Lo mismo se aplica a las etiquetas:
‘main’, ‘MAIN’ o ‘Main’ se consideran la misma etiqueta.</p>
<pre><code>; Imprime todos los caracteres ASCII entre el código 32 y 128.
; Es una variación del primer ejemplo presentado en el
; manual de MAXAM

main              ; define la etiqueta global &#39;main&#39;
    ld a,32       ; primer código de letra ASCII en el acumulador

!loop             ; define la etiqueta local &#39;loop&#39;
    call &amp;BB5A    ; LLAMA a txt_output, la rutina de salida del firmware
    inc  a        ; pasa al siguiente carácter
    cp   128      ; ¿hemos terminado con todos?
    jr   c,!loop  ; no - regresa para procesar el siguiente

.end  
    jp   end      ; bucle infinito usado como punto final del programa
</code></pre>
<p>Otro aspecto importante de ABASM es que permite usar el símbolo ‘!’
al principio de las etiquetas para definir las que son locales y solo
accesibles desde el archivo o módulo en el que son declaradas.</p>
<h2 id="comentarios">Comentarios</h2>
<p>Los comentarios en código ensamblador son anotaciones escritas por el
programador que no serán interpretadas ni ejecutadas por la CPU. Su
objetivo es proporcionar información adicional sobre el código para
hacerlo más comprensible y mantenible.</p>
<p>Los comentarios son importantes en cualquier lenguaje de
programación, pero en ensamblador adquieren una relevancia aún mayor, ya
que debido al bajo nivel de abstracción del lenguaje, el código no suele
ser fácil de interpretar. Por lo tanto, son cruciales para explicar su
propósito y funcionamiento. Como norma general, se recomienda hacer uso
de los comentarios para:</p>
<ul>
<li>Describir partes complejas del código, explicando qué hace una
secuencia particular de instrucciones o los parámetros y valores que
devuelve una subrutina.</li>
<li>Delimitar secciones del código, como bucles, funciones o bloques
lógicos.</li>
<li>Proporcionar contexto, indicando el propósito de una variable,
etiqueta o constante.</li>
</ul>
<p>En ABASM, los comentarios suelen indicarse con el carácter ‘;’ (punto
y coma). Cuando ABASM encuentra este carácter, procede a ignorar el
resto de la línea.</p>
<pre><code>; Esto es un comentario
; Esto es otro comentario</code></pre>
<h2 id="etiquetas">Etiquetas</h2>
<p>Las etiquetas en el código ensamblador son nombres simbólicos
utilizados para marcar una posición específica en el programa, como una
dirección de memoria o una instrucción. Sus principales usos son:</p>
<ul>
<li><p>En saltos y bucles: Las etiquetas se usan como destinos en
instrucciones de salto (JMP, JE, etc.), permitiendo redirigir el flujo
de ejecución a una parte específica del programa.</p></li>
<li><p>En la definición de datos: Se utilizan para referirse a variables
o datos en memoria, facilitando su acceso y manipulación.</p></li>
<li><p>Como puntos de entrada a bloques de código: Ayudan a hacer el
código más legible y fácil de mantener al proporcionar nombres
descriptivos a secciones importantes del programa.</p></li>
</ul>
<p>Todas las etiquetas son <strong>globales</strong> por defecto, lo que
significa que deben ser únicas sin importar en cuántos archivos esté
dividido el código fuente. ABASM ignora el carácter inicial ‘.’ en la
definición de etiquetas para admitir el formato de declaración de
etiquetas de WinApe.</p>
<p>Para crear una etiqueta local (restringida a un módulo/archivo o
dentro de una macro), debe comenzar con el símbolo ‘!’. Si la etiqueta
se define fuera de una macro, se considera una <strong>etiqueta local
del módulo</strong>, accesible solo dentro del archivo donde se declara.
Esto también evita que la etiqueta aparezca en el archivo de
símbolos.</p>
<p>Si la etiqueta se define dentro de una macro, se trata como una
<strong>etiqueta local de macro</strong>. Las etiquetas locales de macro
son esenciales para evitar errores causados por redefiniciones de
etiquetas cuando la macro se invoca varias veces.</p>
<pre><code>!loop
  &lt;algo de código&gt;
  dec b
  jr z,!loop</code></pre>
<h2 id="instrucciones">Instrucciones</h2>
<p>Las instrucciones son operaciones que debe realizar la CPU (el
procesador Z80 en nuestro caso). El proceso de ensamblar consiste en
generar el código binario correspondiente a estas instrucciones. Cada
instrucción suele estar compuesta por un <em>opcode</em> y sus
<em>operandos</em>.</p>
<p>Un opcode (abreviatura de “operation code” o código de operación) es
la parte de una instrucción que especifica la acción que debe realizar
la CPU. Es un valor binario o hexadecimal único asociado a una operación
particular, como sumar, restar, cargar un valor en un registro o
realizar una comparación. Por lo tanto, el opcode determina la operación
a ejecutar, mientras que los operandos (si los hay) proporcionan los
datos necesarios para dicha operación. Por ejemplo:</p>
<pre><code>ld a,32</code></pre>
<p>El <em>opcode</em> (el nemotécnico asociado más bien) sería ‘ld a’,
mientras que el operando sería ‘32’. El significado del opcode es
‘cargar en el registro A’, mientras que el valor a cargar sería
directamente el número 32.</p>
<p>ABASM soporta todas las instrucciones estándar del Z80. Con la
intención de mejorar la compatibilidad con la sintaxis de WinAPE,
algunas instrucciones como AND, CP, OR y SUB pueden incluir el registro
A como parte del <em>opcode</em>. Sin embargo, se prefiere la forma
abreviada sin el A explícito. Los usuarios pueden controlar como de
permisivo es el ensablador a través del parámetro
<code>--tolerance NIVEL</code>. Según su valor, estas variaciones pueden
considerarse un error, emitir un <em>warning</em> o ser aceptadas por
completo.</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr>
<th>Nivel de tolerancia</th>
<th>Comportamiento</th>
</tr>
</thead>
<tbody>
<tr>
<td>–tolerance 0</td>
<td>Valor por defecto, el modo más estricto. Los opcodes SUB A, CP A,
etc., tolerados por WinApe producen un error de sintaxis en ABASM.</td>
</tr>
<tr>
<td>–tolerance 1</td>
<td>Los opcodes alternativos de WinApe SUB A, CP A, etc., producen un
<em>warning</em> pero no detienen el ensamblado.</td>
</tr>
<tr>
<td>–tolerance 2</td>
<td>Los opcodes alternativos se aceptan completamente. Los errores
debidos a truncamientos, por ejemplo, valor de dos bytes utilizado en un
operando de un byte, producen <em>warnings</em> en vez de errores.</td>
</tr>
</tbody>
</table>
<p>A nivel de operandos, ABASM es totalmente compatible con los
registros estándar de 8 bits del Z80: A, B, C, D, E, H y L, así como con
los registros especiales de 8 bits I y R. También es compatible con
todos los registros estándar de 16 bits del Z80: AF, BC, DE, HL y SP,
junto con los registros de índice IX e IY. Además, ABASM ofrece soporte
para el uso no documentado de las porciones de 8 bits de los registros
IX e IY, permitiendo el uso de IXL, IXH, IYL e IYH. El registro
alternativo AF’ también se puede utilizar en las instrucciones
adecuadas, como con la instrucción <code>EX AF, AF'</code>.</p>
<p>Por último, ABASM soporta las condiciones habituales NZ, Z, NC, C,
PO, PE, P y M en las instrucciones diseñadas para tal fin, como, por
ejemplo, las intrucciones de salto condicional.</p>
<p>Para consultar los detalles específicos sobre cada instrucción, se
puede recurrir a la lista incluida en la sección
<code>Conjunto de instrucciones del Z80</code> o a los siguientes sitios
web (en inglés):</p>
<ul>
<li><a href="https://clrhome.org/table/"><span class="citation"
data-cites="ClrHome">@ClrHome</span> Tabla de Instrucciones del Z80</a>:
Una tabla bien organizada que proporciona un resumen conciso de todas
las instrucciones del Z80.</li>
<li><a href="https://www.zilog.com/docs/z80/um0080.pdf">Documentación
oficial de Zilog para el procesador Z80</a>: Especialmente útiles son
las dos últimas secciones tituladas <em>Z80 CPU Instructions</em> y
<em>Z80 Instruction Set</em>.</li>
<li><a href="http://z80-heaven.wikidot.com/">Z80 Heaven</a>: Una web de
referencia con información detallada de cada instrucción.</li>
</ul>
<p>En español, se pueden consultar los siguientes enlaces:</p>
<ul>
<li><a
href="https://ia801404.us.archive.org/7/items/z80-cpu-manual/ES%20-%20Z80%20CPU%20Manual.pdf">Resumen
sobre el procesador Z80</a>: Un documento de 19 páginas con un buen
resumen del procesador Z80 y su juego de instrucciones.</li>
<li><a
href="https://www.infor.uva.es/~bastida/OC/Tablas%20Z80%20SPARC%20y%20ASCII.pdf">Juego
de instrucciones del microprocesador Z80</a>: Otro buen documento
centrado en las instrucciones soportadas por el procesador Z80.</li>
<li><a href="https://www.cpcwiki.eu/index.php/DEZ80">Dominando el
ensamblador Z80 (DEZ80) de la Universidad de Alicante</a>: Serie de
librosCurso de programación en ensamblador para el Amstrad CPC impartido
por el profesor Francisco Gallego y en formato de vídeos.</li>
</ul>
<h2 id="bibliotecas">Bibliotecas</h2>
<p>La directiva <code>read</code> permite incluir archivos adicionales
desde un archivo principal. Estos archivos pueden ser locales o residir
dentro de la carpeta <code>lib</code> de la instalación. De esta manera,
es posible crear bibliotecas reutilizables entre proyectos.</p>
<p>Como ejemplo, la distribución de <strong>ABASM</strong> incluye una
versión reducida de la biblioteca <strong>CPCRSLIB</strong> y una
versión completa de la biblioteca <strong>CPCTELERA</strong>. Para
obtener más detalles, puedes consultar los ejemplos disponibles en la
carpeta <code>examples/cpcrslib</code> y
<code>examples/cpctelera</code>.</p>
<h2 id="directivas-del-ensamblador">Directivas del Ensamblador</h2>
<p>Una directiva en ensamblador es una instrucción que no se traduce
directamente en código máquina para la CPU, sino que proporciona
información o instrucciones al ensamblador sobre cómo procesar el código
fuente. Estas directivas controlan aspectos del proceso de ensamblado,
como la organización del código, la definición de datos, la asignación
de memoria y la definición de constantes. A diferencia de las
instrucciones que se ejecutan en la CPU, las directivas solo afectan al
ensamblador durante el ensamblado del código fuente. Ejemplos comunes
incluyen ORG (para establecer la dirección de inicio), EQU (para definir
constantes) o DB (para definir datos en memoria). A continuación, se
presenta una lista completa de las directivas soportadas por ABASM y su
significado:</p>
<h3 id="align">ALIGN</h3>
<ul>
<li>ALIGN n [,v]</li>
</ul>
<p><em>n</em> debe ser un número o una expresión numérica que sea una
potencia de dos. Esta directiva añade los bytes necesarios para que la
memoria utilizada hasta ese momento por el programa sea un múltiplo de
<em>n</em>. El segundo parámetro opcional establece el valor con el que
debe rellenarse la memoria necesaria (un valor entre 0 y 255). Si no se
especifica este segundo argumento, la memoria se rellena con ceros.</p>
<p>Por ejemplo:</p>
<pre><code>main:
    LD A, 0xFF
    ALIGN 8
data:
    DB 0xAA, 0xBB, 0xCC</code></pre>
<p>Esto producirá el siguiente código binario:</p>
<pre><code>3E FF 00 00 00 00 00 00 AA BB CC</code></pre>
<h3 id="assert">ASSERT</h3>
<ul>
<li>ASSERT condición</li>
</ul>
<p>Esta directiva evalúa si la condición proporcionada se cumple. Si no
es así, aborta el proceso de ensamblado. Por ejemplo, el siguiente
código verifica que la siguiente instrucción a ensamblar no ocupe una
posición de memoria superior al inicio de la memoria de video (0xC000 en
el Amstrad CPC).</p>
<pre><code>ASSERT @&lt;0xC000</code></pre>
<p>Los operadores básicos que se pueden usar en estar expresiones son: -
<em>==</em> : igual que. - <em>!=</em> : distinto que. - <em>&lt;</em>,
<em>&gt;</em> : menor que o mayor que.<br />
- <em>&lt;=</em>, <em>&gt;=</em>: menor o igual que, mayor o igual
que.</p>
<h3 id="db-dm-defb-defm">DB, DM, DEFB, DEFM</h3>
<ul>
<li>DEFB n [,n …]</li>
<li>DEFM n [,n …]</li>
<li>DB n [,n …]</li>
<li>DM n [,n …]</li>
</ul>
<p>Almacena en la posición actual de memoria la lista de bytes
proporcionada como parámetro. <em>n</em> puede ser un número o una
expresión numérica en el rango de 0 a 255 (0x00 a 0xFF).</p>
<pre><code>DB 0xFF, 0xFF, 0xFF, 0xFF</code></pre>
<p>También es posible usar una cadena de texto como parámetro y
combinarla con el formato anterior. En este caso, se almacenarán los
códigos ASCII de cada letra como si fueran los valores numéricos
proporcionados.</p>
<pre><code>DB &quot;Hola Mundo&quot;,0x00</code></pre>
<h3 id="ds-defs-rmem">DS, DEFS, RMEM</h3>
<ul>
<li>DEFS n</li>
<li>DS n</li>
<li>RMEM n</li>
</ul>
<p>Reserva <em>n</em> bytes de memoria. Básicamente, la posición actual
de memoria se incrementa en <em>n</em> bytes, dejándola libre para su
uso posterior.</p>
<h3 id="dw-defw">DW, DEFW</h3>
<ul>
<li>DEFW n [,n …]</li>
<li>DW n [,n …]</li>
</ul>
<p>Almacena <em>palabras</em> (dos bytes en formato little-endian) en la
posición actual de memoria. <em>n</em> puede ser un número o una
expresión numérica en el rango de 0 a 65535 (0x0000 a 0xFFFF).</p>
<pre><code>year:
    DW  2024</code></pre>
<h3 id="equ">EQU</h3>
<ul>
<li>EQU símbolo, valor</li>
<li>símbolo EQU valor</li>
</ul>
<p>Permite establecer el valor de un símbolo, normalmente utilizado como
constante.</p>
<pre><code>EQU MEM_VIDEO, 0xC000

LD  A,0xFF
LD  (MEM_VIDEO),A</code></pre>
<h3 id="if">IF</h3>
<ul>
<li>IF condición [ELSEIF condición | ELSE] ENDIF</li>
</ul>
<p>La directiva IF permite que ciertas partes del código se incluyan o
se ignoren, dependiendo del valor de una expresión lógica. Dicha
expresión puede contener símbolos y valores numéricos. Si la expresión
es verdadera (distinta de cero), el ensamblador procesará las líneas que
siguen a la directiva IF. Si es falsa (igual a cero), esas líneas serán
ignoradas.</p>
<p>Una estructura básica de IF podría ser:</p>
<pre><code>IF expresión
    ; Código ensamblado si la expresión es verdadera
ELSE
    ; Código ensamblado si la expresión es falsa
ENDIF</code></pre>
<p>Esta directiva es útil cuando se combina con la opción
<code>--define</code> de ABASM, que permite cambiar qué código se
ensambla dependiendo de la llamada hecha al ensamblador. Sin embargo,
cualquier símbolo o constante referenciada en la expresión lógica debe
haberse declarado previamente.</p>
<p>Los operadores básicos que se pueden usar en estar expresiones son: -
<em>=</em> : aunque == es el operador adecuado, ABASM soporta ‘=’ por
compatibilidad con WinAPE. - <em>==</em> : igual que. - <em>!=</em> :
distinto que. - <em>&lt;</em>, <em>&gt;</em> : menor que o mayor
que.<br />
- <em>&lt;=</em>, <em>&gt;=</em>: menor o igual que, mayor o igual
que.</p>
<h3 id="ifnot">IFNOT</h3>
<ul>
<li>IFNOT condición [ELSEIF condición | ELSE] ENDIF</li>
</ul>
<p>La directiva IFNOT permite que ciertas partes del código se incluyan
o se ignoren, dependiendo del valor de una expresión lógica, de igual
forma a como se comporta la directiva <code>IF</code>. Sin embargo, el
ensamblador procesará las líneas que siguen a la directiva IFNOT solo
cuando dicha expresión sea falsa (igual a cero).</p>
<h3 id="incbin">INCBIN</h3>
<ul>
<li>INCBIN “fichero binario”</li>
</ul>
<p>Esta directiva inserta el contenido del fichero especificado entre
comillas dobles. La ruta del fichero debe ser relativa a la ubicación
del fichero que lo incluye.</p>
<pre><code>INCBIN &quot;./assets/mysprite.bin&quot;</code></pre>
<h3 id="macro">MACRO</h3>
<ul>
<li>MACRO símbolo [param1, param2, …] ENDM</li>
</ul>
<p>Esta directiva permite asignar un nombre o símbolo a un bloque de
código que se extiende hasta la siguiente ocurrencia de ENDM. La macro
puede incluir una lista de parámetros que serán sustituidos por los
valores proporcionados en futuras <em>llamadas</em> a la macro. Una vez
definida, una macro puede utilizarse en el resto del código como si
fuera una instrucción convencional. Los parámetros se buscan en el
código de la macro y se sustituyen por los valores pasados en la
<em>llamada</em>. Por ese motivo, puede ser una buena práctica comenzar
y finalizar cada nombre de parámetro con el carácter ’_’; evitando, de
ese modo, coincidencias accidentales con otras cadenas de texto o con
nombres de registros o directivas.</p>
<pre><code>macro get_screenPtr _REG_, _X_, _Y_ 
   ld _REG_, &amp;C000 + 80 * (_Y_ / 8) + 2048 * (_Y_ &amp; 7) + _X_ 
endm

main:
   get_screenPtr hl, 20, 10</code></pre>
<p>El código de una macro puede contener <em>llamadas</em> a otras
macros, pero no es posible definir una nueva macro ni utilizar la
directiva <strong>READ</strong>. Si una macro contiene una etiqueta
normal (global o local al módulo) y se <em>llama</em> más de una vez, el
ensamblador detectará una redefinición de la etiqueta, lo que provocará
un error. Si una macro necesita emplear etiquetas en su código, estas
deben ir precedidas del símbolo ‘!’, lo que las identificará como
<strong>etiquetas locales a la macro</strong>.</p>
<pre><code>macro decnz_a
  or a
  jr z,!leave
  dec a
  !leave
mend</code></pre>
<p>WinApe utiliza el símbolo ‘@’ para identificar <strong>etiquetas de
macro locales</strong>, pero ese símbolo lo utiliza ABASM como la
dirección actual en memoria para el código ensamblado. Por tanto, ABASM
no es compatible con WinApe en este aspecto.</p>
<p>Si una misma macro se define una segunda vez, la segunda definición
pasa a ser la valida desde ese momento. Sin embargo, también es posible
emplear la directiva <code>MDELETE símbolo</code> para eliminar una
definición existente.</p>
<h3 id="let">LET</h3>
<ul>
<li>LET símbolo=valor</li>
</ul>
<p>Esta directiva permite cambiar el valor de un símbolo o constante.
Este símbolo o constante debe haber sido definido inicialmente con
LET.</p>
<pre><code>LET PADDING=0x00
&lt;código&gt;
LET PADDING=0xFF
&lt;más código&gt;</code></pre>
<h3 id="limit">LIMIT</h3>
<ul>
<li>LIMIT dirección_de_memoria</li>
</ul>
<p>Establece la dirección máxima de memoria que puede alcanzar el
programa ensamblado. El valor suministrado puede ser un número o una
expresión numérica. Por defecto, este valor es 65536 (64K).</p>
<pre><code>LIMIT &amp;C000   ; protegemos la memoria de video que empieza en &amp;C000
ORG &amp;C000
LD A,&amp;FF      ; esta linea causará un error</code></pre>
<h3 id="read">READ</h3>
<ul>
<li>READ “fichero de código fuente”</li>
</ul>
<p>Esta directiva inserta el contenido del fichero especificado entre
comillas dobles o siemples y lo ensambla. La ruta del fichero debe ser
relativa a la ubicación del fichero que lo incluye. Todos los símbolos
definidos en el fichero insertado son globales, por lo que deben ser
únicos y no repetirse en el fichero principal ni en ningún otro fichero
incluido mediante este método. Si un mismo fichero se incluye varias
veces, ABASM lo detectará y solo lo incluirá una vez.</p>
<pre><code>READ &quot;./lib/keyboard.asm&quot;</code></pre>
<h3 id="repeat">REPEAT</h3>
<ul>
<li>REPEAT expresión numérica <code>bloque de código</code> REND</li>
</ul>
<p>Repite un bloque de código tantas veces como el valor indicado por la
expresión numérica. No puede utilizarse dentro de la definición de una
macro.</p>
<pre><code>EQU ENTITIES, 10
LET ENTITY_ID = 0
REPEAT ENTITIES
  DB 0x00       ; X pos
  DB 0x00       ; Y pos
  DB ENTITY_ID  ; Entity ID
  LET ENTITY_ID = ENTITY_ID + 1
REND</code></pre>
<h3 id="org">ORG</h3>
<ul>
<li>ORG dirección_de_memoria</li>
</ul>
<p>Especifica la dirección de memoria que debe considerarse como la
actual a partir de ese momento para cualquier cálculo necesario, como
establecer el valor de una etiqueta. Lo habitual es que esta directiva
aparezca como la primera instrucción del código fuente, aunque puede
substituirse por la opción de ABASM <code>--start</code>.</p>
<pre><code>ORG 0x4000</code></pre>
<p>Nada impide incluir más de una ocurrencia de esta directiva en el
código fuente, aunque hay que tener presente que cualquier zona de
memoria “vacia” que quede entre la dirección de memoria inicial del
programa y la dirección más alta será rellenada con 0s, aumentando el
tamaño del fichero <code>bin</code> resultante. Para evitarlo, si un
programa necesita tener partes cargadas en diferentes áreas de la
memoria, es aconsejable generar un fichero binario independiente para
cada área y empaquetarlos todos dentro del mismo DSK o CDT, junto con un
cargador programado en BASIC (por ejemplo).</p>
<h3 id="print">PRINT</h3>
<ul>
<li>PRINT expresión[, expresión …]</li>
</ul>
<p>Imprime el resultado de la(s) expresión(es) proporcionada(s) en la
salida estándar tan pronto como se evalúe durante el ensamblado. Esto
puede ser útil para generar información adicional durante el ensamblado,
como la memoria total que consume el programa.</p>
<pre><code>ORG 0x4000
&lt;código&gt;
PRINT @-0x4000</code></pre>
<h3 id="save">SAVE</h3>
<ul>
<li>SAVE “fichero”, expresión numérica, expresion numérica</li>
</ul>
<p>Esta directiva permite generar archivos binarios adicionales con el
contenido de la memoria en la que se está escribiendo el código
ensamblado. La memoria tiene un tamaño máximo de 64K, que corresponde al
límite del Amstrad CPC 464. La primera expresión define la dirección de
inicio, mientras que la segunda especifica la cantidad total de bytes
que se escribirán en el archivo.</p>
<pre><code>SAVE &quot;myscreen.bin&quot;,&amp;C000,&amp;4000</code></pre>
<h3 id="stop">STOP</h3>
<ul>
<li>STOP</li>
</ul>
<p>Detiene inmediatamente el proceso de ensamblado mostrando un
error.</p>
<h3 id="while">WHILE</h3>
<ul>
<li>WHILE expresión lógica <code>bloque de código</code> WEND</li>
</ul>
<p>Permite ensamblar repetidamente un bloque de código mientras se
cumpla la condición especificada. Si la condición nunca llega a ser
falsa, esta directiva puede generar un bucle infinito. No puede
utilizarse dentro de la definición de una macro.</p>
<pre><code>LET OBJECTS = 32
WHILE OBJECTS&gt;0
  db 0
  db 0
  db 0
  LET OBJECTS = OBJECTS-1
WEND</code></pre>
<h2 id="expresiones-y-caracteres-especiales">Expresiones y Caracteres
Especiales</h2>
<p>Cuando una instrucción o directiva requiere un número como parámetro,
se puede usar una expresión matemática en su lugar. Estas expresiones
pueden hacer referencia a cualquier símbolo definido en el código. Si el
resultado de una expresión es negativo, se utiliza su complemento a dos
como valor. Además, algunos símbolos tienen significados especiales, que
se detallan a continuación:</p>
<ul>
<li><strong>$</strong> representa la dirección de memoria de la
instrucción actual.</li>
<li><strong><span class="citation" data-cites="*">@*</span>* es
intercambiable con el símbolo </strong>$**.</li>
<li>El prefijo <strong>&amp;</strong> indica números en formato
hexadecimal (por ejemplo, &amp;FF).</li>
<li>El prefijo <strong>#</strong> indica números en formato hexadecimal
(por ejemplo, #FF).</li>
<li>El prefijo <strong>0x</strong> también indica números en formato
hexadecimal (por ejemplo, 0xFF).</li>
<li>El prefijo <strong>%</strong> indica números en formato binario (por
ejemplo, %11111111).</li>
<li>El prefijo <strong>0b</strong> también indica números en formato
binario (por ejemplo, 0b11111111).</li>
<li>Las comillas dobles <strong>“</strong> delimitan caracteres o
cadenas de texto (1).</li>
<li>Las comillas simples <strong>’</strong> son equivalentes a las
dobles para delimitar cadenas de texto.</li>
<li><strong>MOD</strong> es el operador módulo: op1 MOD op2.</li>
<li><strong>AND</strong> es el operador bit a bit AND: op1 AND op2.
También se puede usar el operador &amp; de Python.</li>
<li><strong>OR</strong> es el operador bit a bit OR: op1 OR op2. También
se puede usar el operador | de Python.</li>
<li><strong>XOR</strong> es el operador bit a bit XOR: op1 XOR op2.
También se puede usar el operador ^ de Python.</li>
<li><strong>&lt;&lt;</strong> es el operador <em>desplazamiento</em> a
la izquierda.</li>
<li><strong>&gt;&gt;</strong> es el operador <em>desplazamiento</em> a
la derecha.</li>
</ul>
<ol type="1">
<li>Un único carácter entre comillas dobles puede usarse para
representar el valor ASCII de ese carácter en expresiones numéricas. Ni
las comillas dobles ni las simples pueden aparecer dentro de una cadena
de texto.</li>
</ol>
<h1 id="bibliotecas-incluidas-en-abasm">Bibliotecas incluidas en
ABASM</h1>
<p><code>ABASM</code> incluye dos bibliotecas listas para uso.. Ambas
con un gran recurso para aprender más sobre los entresijos del Amstrad
CPC, incluyendo su preculiar organización de la memoria de vídeo.</p>
<h2 id="cpcrslib">CPCRSLIB</h2>
<p>CPCRSlib es una biblioteca en C que proporciona rutinas y funciones
para la gestión de sprites y mapas de tiles en el Amstrad CPC. La
biblioteca está diseñada para su uso con los compiladores Z88DK o SDCC.
CPCRSlib también incluye rutinas de teclado para la redefinición y
detección de teclas, así como rutinas de propósito general para cambiar
el modo de pantalla y los colores.</p>
<p>Además, CPCRSLIB incorpora un reproductor de música y efectos de
sonido desarrollado por WYZ, capaz de reproducir música creada con
WYZTracker.</p>
<ul>
<li>Una explicación detallada de cada función y rutina se puede
consultar aquí: <a
href="http://www.amstrad.es/programacion/cpcrslib.html">http://www.amstrad.es/programacion/cpcrslib.html</a></li>
<li>La última versión oficial de la biblioteca original puede
descargarse desde: <a
href="http://sourceforge/cpcrslib">http://sourceforge/cpcrslib</a></li>
</ul>
<p>La versión incluida con <code>ABASM</code> no incorpora soporte para
el desplazamiento de tilemaps. Adicionalmente, algunas rutinas han sido
renombradas para mejorar la claridad y la coherencia. Consulta los
ejemplos ubicados en <code>examples/cpcrslib</code> para aprender más
sobre el uso de esta biblioteca dentro de <code>ABASM</code>.</p>
<h2 id="cpctelera">CPCTELERA</h2>
<p>CPCtelera es un framework multiplataforma para el desarrollo de
videojuegos y software multimedia para el Amstrad CPC. Funciona en
Linux, macOS y Windows (mediante Cygwin) y facilita el desarrollo de
software para Amstrad CPC tanto en lenguaje C como en ensamblador.
CPCtelera requiere el uso del compilador SDCC y el ensamblador que
incluye.</p>
<p>CPCtelera está ampliamente documentada, dispone de un completo manual
de referencia y su código fuente está profusamente comentado. Todos los
detalles y la documentación pueden consultarse en:</p>
<ul>
<li><a
href="https://lronaldo.github.io/cpctelera/">https://lronaldo.github.io/cpctelera/</a></li>
<li><a
href="https://lronaldo.github.io/cpctelera/files/readme-txt.html">https://lronaldo.github.io/cpctelera/files/readme-txt.html</a></li>
</ul>
<p>El port incluido en <code>ABASM</code> cubre todas las rutinas
disponibles en la versión 1.5-dev de CPCtelera. La principal diferencia
es que el sufijo <code>_asm</code> ha sido eliminado de los nombres de
las rutinas, ya que en este contexto no existe ambigüedad entre código C
y ensamblador. Para aprender más sobre el uso de esta biblioteca dentro
de <code>ABASM</code> pueden consultarse los ejemplos incluidos en
<code>examples/cpctelera</code>.</p>
<h1 id="conjunto-de-instrucciones-del-z80">Conjunto de instrucciones del
Z80</h1>
<p>Esta sección proporciona una lista breve de todas las instrucciones
soportadas del Z80. Lo habitual en muchos otros lugares es indicar los
tiempos de ejecución en ciclos o <em>T-states</em>. Sin embargo, el
Amstrad CPC tiene su propia temporización debido a que el Gate Array
pausa el Z80 para acceder a la memoria de video. Por lo tanto, es más
preciso medir los tiempos de ejecución en función del coste de la
instrucción NOP (1 microsegundo). Los tiempos de cada instrucción
también se pueden consultar en la siguiente página web:</p>
<ul>
<li><a
href="https://www.cpcwiki.eu/imgs/b/b4/Z80_CPC_Timings_cheat_sheet.20230709.pdf">Tiempos
del Z80 para el Amstrad CPC - Hoja de referencia rápida</a></li>
</ul>
<p><strong>Claves:</strong></p>
<pre><code>r     registro de 8 bits (B,C,D,E,H,L,A)
n     valor numérico de 8 bits (rango 0-254)
hh    valor hexadecimal de 8 bits (rango &amp;00-&amp;FF)
d     offset numérico de 1 byte (-128 a 127)

rr    registro doble de 16 bits (HL,DE,BC)
nn    valor numérico de 16 bits (rango 0-65535)
HHhh    valor hexadecimal de 16 bits (rango &amp;0000-&amp;FFFF)

cc    condición (z,nz,c,nc,p,m,po,pe)
cn    condición no satisfecha
cs    condición satisfecha

b     posición de un bit dentro de un byte (7-0)</code></pre>
<p><strong>Lista de instrucciones:</strong></p>
<pre><code>bytes         opcode        tiempo    explicación
-------------------------------------------------------------------------------
8F              ADC   A,A       1 Suma con acarreo el registro r al acumulador.
88              ADC   A,B
89              ADC   A,C
8A              ADC   A,D
8B              ADC   A,E
8C              ADC   A,H
8D              ADC   A,L
CE hh           ADC   A,n       2 Suma con acarreo el valor n al acumulador.
DD 8C           ADC   A,IXH     2 Suma con acarreo el byte alto de IX al acumulador.
DD 8D           ADC   A,IXL     2 Suma con acarreo el byte bajo de IX al acumulador.
FD 8C           ADC   A,IYH     2 Suma con acarreo el byte alto de IY al acumulador.
FD 8D           ADC   A,IYL     2 Suma con acarreo el byte bajo de IY al acumulador.
8E              ADC   A,(HL)    2 Suma con acarreo el valor en la ubicación HL al acumulador.
DD 8E hh        ADC   A,(IX+d)  5 Suma con acarreo el valor en la ubicación IX+d al acumulador.
FD 8E hh        ADC   A,(IY+d)  5 Suma con acarreo el valor en la ubicación IY+d al acumulador.
ED 4A           ADC   HL,BC     4 Suma con acarreo el registro doble rr a HL.
ED 5A           ADC   HL,DE
ED 6A           ADC   HL,HL
ED 7A           ADC   HL,SP

87              ADD   A,A       1 Suma el registro r al acumulador.
80              ADD   A,B
81              ADD   A,C
82              ADD   A,D
83              ADD   A,E
84              ADD   A,H
85              ADD   A,L
C6 hh           ADD   A,n       2 Suma el valor n al acumulador.
DD 84           ADD   A,IXH     2 Suma el byte alto de IX al acumulador.
DD 85           ADD   A,IXL     2 Suma el byte bajo de IX al acumulador.
FD 84           ADD   A,IYH     2 Suma el byte alto de IY al acumulador.
FD 85           ADD   A,IYL     2 Suma el byte bajo de IY al acumulador.
86              ADD   A,(HL)    2 Suma el valor en la ubicación HL al acumulador.
DD 86 hh        ADD   A,(IX+d)  5 Suma el valor en la ubicación IX+d al acumulador.
FD 86 hh        ADD   A,(IY+d)  5 Suma el valor en la ubicación IY+d al acumulador.
09              ADD   HL,BC     3 Suma el registro doble rr a HL.
19              ADD   HL,DE
29              ADD   HL,HL
39              ADD   HL,SP
DD 09           ADD   IX,BC     4 Suma el registro doble rr a IX.
DD 19           ADD   IX,DE
DD 29           ADD   IX,IX
DD 39           ADD   IX,SP
FD 09           ADD   IY,BC     4 Suma el registro doble rr a IY.
FD 19           ADD   IY,DE
FD 29           ADD   IY,IY
FD 39           ADD   IY,SP

A7              AND   A         1 AND lógico del registro r con el acumulador.
A0              AND   B
A1              AND   C
A2              AND   D
A3              AND   E
A4              AND   H
A5              AND   L
E6 hh           AND   n         2 AND lógico del valor n con el acumulador.
DD A4           AND   IXH       2 AND lógico del byte alto de IX con el acumulador.
DD A5           AND   IXL       2 AND lógico del byte bajo de IX con el acumulador.
FD A4           AND   IYH       2 AND lógico del byte alto de IY con el acumulador.
FD A5           AND   IYL       2 AND lógico del byte bajo de IY con el acumulador.
A6              AND   (HL)      2 AND lógico del valor en la ubicación HL con el acumulador.
DD A6 hh        AND   (IX+d)    5 AND lógico del valor en la ubicación IX+d con el acumulador.
FD A6 hh        AND   (IY+d)    5 AND lógico del valor en la ubicación IY+d con el acumulador.

CB bF           BIT   b,A       2 Chequea si el bit b del registro r es 1.
CB b8           BIT   b,B         El resultado queda en el flag Z.
CB b9           BIT   b,C
CB bA           BIT   b,D
CB bB           BIT   b,E
CB bC           BIT   b,H
CB bD           BIT   b,L
CB bE           BIT   b,(HL)    3 Chequea si el bit b del valor en la ubicación HL es 1.
DD CB hh bE     BIT   b,(IX+d)  6 Chequea si el bit b del valor en la ubicación IX+d.
FD CB hh bE     BIT   b,(IY+d)  6 Chequea si el bit b del valor en la ubicación IY+d.

CD hh HH        CALL  HHhh      5 Llama a la subrutina en la dirección de memoria dada.
CC hh HH        CALL  z,HHhh  3/5 Llama a la subrutina si el flag Z es 1, si no (3).
C4 hh HH        CALL  nz,HHhh 3/5 Llama a la subrutina si el flag Z es 0, si no (3).
DC hh HH        CALL  c,HHhh  3/5 Llama a la subrutina si el flag C es 1, si no (3).
D4 hh HH        CALL  nc,HHhh 3/5 Llama a la subrutina si el flag C es 0, si no (3).
F4 hh HH        CALL  p,HHhh  3/5 Llama a la subrutina si el flag S es 0, si no (3).
FC hh HH        CALL  m,HHhh  3/5 Llama a la subrutina si el flag S es 1, si no (3).
EC hh HH        CALL  pe,HHhh 3/5 Llama a la subrutina si el flag P/V es 1, si no (3).
E4 hh HH        CALL  po,HHhh 3/5 Llama a la subrutina si el flag P/V es 0, si no (3).

3F              CCF             1 Invierte el valor del flag de acarreo.

BF              CP    A         1 Compara el registro r con el acumulador.
B8              CP    B           El flag Z es 1 si A == N si no, es 0.
B9              CP    C           El flag C es 1 si A &lt; N si no, es 0 (sin signo)   
BA              CP    D           El flag S &lt;&gt; P/V si A &lt; N si no, S = P/V (con signo).  
BB              CP    E               
BC              CP    H               
BD              CP    L
FE hh           CP    n         2 Compara el valor n con el acumulador.
DD BC           CP    IXH       1 Compara el byte alto de IX con el acumulador.
DD BD           CP    IXL       1 Compara el byte bajo de IX con el acumulador.
FD BC           CP    IYH       1 Compara el byte alto de IY con el acumulador.
FD BD           CP    IYL       1 Compara el byte bajo de IY con el acumulador.
BE              CP    (HL)      2 Compara el valor de la ubicación en HL con A.
DD BE hh        CP    (IX+d)    5 Compara el valor de la ubicación en IX+d con A.
FD BE hh        CP    (IY+d)    5 Compara el valor de la ubicación en IY+d con A.

ED A9           CPD             5 Compara el valor de la ubicación en HL con A, HL-1, BC-1.
ED B9           CPDR          5/6 Repite CPD hasta que BC=0 (5), si BC&lt;&gt;0 (6).
ED A1           CPI             5 Compara el valor de la ubicación en HL con A, HL+1, BC-1.
ED B1           CPIR          5/6 Repite CPI hasta que BC=0 (5), si BC&lt;&gt;0 (6).
2F              CPL             1 Invierte los bits del acumulador (complemento a 1).

27              DAA             1 Ajusta el acumulador según el formato decimal BCD. 

3D              DEC   A         1 Decrementa el registro r.
05              DEC   B
0D              DEC   C
15              DEC   D
1D              DEC   E
25              DEC   H
2D              DEC   L
DD 25           DEC   IXH       2 Decrementa el byte alto de IX.
DD 2D           DEC   IXL       2 Decrementa el byte bajo de IX.
FD 25           DEC   IYH       2 Decrementa el byte alto de IY.
FD 2D           DEC   IYL       2 Decrementa el byte bajo de IY.
35              DEC   (HL)      3 Decrementa el valor de la ubicación en HL.
DD 35 hh        DEC   (IX+d)    6 Decrementa el valor de la ubicación en IX+d.
FD 35 hh        DEC   (IY+d)    6 Decrementa el valor de la ubicación en IY+d.
0B              DEC   BC        2 Decrementa el registro doble rr.
1B              DEC   DE
2B              DEC   HL
3B              DEC   SP
DD 2B           DEC   IX        3 Decrementa IX.
FD 2B           DEC   IY        3 Decrementa IY.

F3              DI              1 Deshabilita las interrupciones (excepto NMI en 0066h).
hh F4           DJNZ  n       3/4 B-1 y salta de manera relativa si B&lt;&gt;0 (4), si B=0 (3).
FB              EI              1 Habilita las interrupciones.

08              EX    AF,AF&#39;    1 Intercambia el contenido de AF y AF&#39;.
EB              EX    DE,HL     1 Intercambia el contenido de DE y HL.
E3              EX    (SP),HL   6 Intercambia el valor de la ubicación en SP y HL.
DD E3           EX    (SP),IX   7 Intercambia el valor de la ubicación en SP e IX.
FD E3           EX    (SP),IY   7 Intercambia el valor de la ubicación en SP e IX.
D9              EXX             1 Intercambia el contenido de BC,DE,HL con BC&#39;,DE&#39;,HL&#39;.

76              HALT            * Detiene el procesador a la espera de una interrupción.
                                Su tiempo de ejecución es variable.

ED 46           IM    0         2 Establece el modo de interrupción a 0 (dispositivo externo).
ED 56           IM    1         2 Establece el modo de interrupción a 1 (rst 38).
ED 5E           IM    2         2 Establece el modo de interrupción a 2 (salto a vector).

DB hh           IN    A,(n)     3 Carga el acumulador con un valor del dispositivo/puerto n.
ED 40           IN    B,(C)     4 Carga el registro r con un valor del dispositivo/puerto en B.
ED 48           IN    C,(C)       Ver nota [1] al final del listado.
ED 50           IN    D,(C)
ED 58           IN    E,(C)
ED 60           IN    H,(C)
ED 68           IN    L,(C)

3C              INC   A         1 Incrementa el valor del registro r.
04              INC   B
0C              INC   C
14              INC   D
1C              INC   E
24              INC   H
2C              INC   L
DD 24           INC   IXH       2 Incrementa el valor del byte alto de IX.
DD 2C           INC   IXL       2 Incrementa el valor del byte bajo de IX.
FD 24           INC   IYH       2 Incrementa el valor del byte alto de IY.
FD 2C           INC   IYL       2 Incrementa el valor del byte bajo de IY.
34              INC   (HL)      3 Incrementa el valor en la ubicación de HL.
DD 34 hh        INC   (IX+d)    6 Incrementa el valor en la ubicación IX+d.
FD 34 hh        INC   (IY+d)    6 Incrementa el valor en la ubicación IY+d.
03              INC   BC        2 Incrementa el valor del registro doble rr.
13              INC   DE
23              INC   HL
33              INC   SP
DD 23           INC   IX        3 Incrementa el valor del registro IX.
FD 23           INC   IY        3 Incrementa el valor del registro IY

ED AA           IND             5 (HL) guarda el valor del dispositivo B!![1], HL-1 y B-1!![1].
ED BA           INDR          5/6 Realiza un IND y repite hasta que B=0 (5), si B&lt;&gt;0 (6) !![1].
ED A2           INI             5 (HL) guarda el valor del dispositivo B!![1], HL+1, B-1 !![1].
ED B2           INIR          5/6 Realiza un INI y repite hasta que B=0 (5), si B&lt;&gt;0 (6) !![1].

C3 hh HH        JP    HHhh      3 Salto incondicional a la dirección HHhh.
E9              JP    (HL)      1 Salto incondicional a la ubicación en HL.
DD E9           JP    (IX)      2 Salto incondicional a la ubicación en IX.
FD E9           JP    (IY)      2 Salto incondicional a la ubicación en IY.
CA hh HH        JP    z,HHhh    3 Salto a HHhh si el flag Z es 1.
C2 hh HH        JP    nz,HHhh   3 Salto a HHhh si el flag Z es 0.
DA hh HH        JP    c,HHhh    3 Salto a HHhh si el flag C es 1.
D2 hh HH        JP    nc,HHhh   3 Salto a HHhh si el flag C es 0.
F2 hh HH        JP    p,HHhh    3 Salto a HHhh si el flag S es 0.
FA hh HH        JP    m,HHhh    3 Salto a HHhh si el flag S es 1.
EA hh HH        JP    pe,HHhh   3 Salto a HHhh si el flag P/V es 1.
E2 hh HH        JP    po,HHhh   3 Salto a HHhh si el flag P/V es 0.

18 hh           JR    n         3 Salto incondicional relativo a PC+n.       
28 hh           JR    z,n     2/3 Salto relativo a PC+n si el flag Z es 1 (3), si no (2).
20 hh           JR    nz,n    2/3 Salto relativo a PC+n si el flag Z es 0 (3), si no (2).
38 hh           JR    c,n     2/3 Salto relativo a PC+n si el flag C es 1 (3), si no (2).
30 hh           JR    nc,n    2/3 Salto relativo a PC+n si el flag C es 0 (3), si no (2).

7F              LD    A,A       1 Copia en el acumulador el valor del registro r.
78              LD    A,B
79              LD    A,C
7A              LD    A,D
7B              LD    A,E
7C              LD    A,H
7D              LD    A,L
ED 5F           LD    A,R       3 Copia en A el valor de R (registro de refresco de memoria).
ED 57           LD    A,I       3 Copia en A el valor de I (registro de vector de interrupción).
DD 7C           LD    A,IXH     2 Copia en A el valor del byte alto de IX.
DD 7D           LD    A,IXL     2 Copia en A el valor del byte bajo de IX.
FD 7C           LD    A,IYH     2 Copia en A el valor del byte alto de IY.
FD 7D           LD    A,IYL     2 Copia en A el valor del byte bajo de IY.

47              LD    B,A       1 Copia en B el valor del registro r.
40              LD    B,B
41              LD    B,C
42              LD    B,D
43              LD    B,E
44              LD    B,H
45              LD    B,L
DD 44           LD    B,IXH     2 Copia en B el valor del byte alto de IX.
DD 45           LD    B,IXL     2 Copia en B el valor del byte bajo de IX.
FD 44           LD    B,IYH     2 Copia en B el valor del byte alto de IY.
FD 45           LD    B,IYL     2 Copia en B el valor del byte bajo de IY.

4F              LD    C,A       1 Copia en C el valor del registro r.
48              LD    C,B
49              LD    C,C
4A              LD    C,D
4B              LD    C,E
4C              LD    C,H
4D              LD    C,L
DD 4C           LD    C,IXH     2 Copia en C el valor del byte alto de IX.
DD 4D           LD    C,IXL     2 Copia en C el valor del byte bajo de IX.
FD 4C           LD    C,IYH     2 Copia en C el valor del byte alto de IY.
FD 4D           LD    C,IYL     2 Copia en C el valor del byte bajo de IY.

57              LD    D,A       1 Copia en D el valor del registro r.
50              LD    D,B
51              LD    D,C
52              LD    D,D
53              LD    D,E
54              LD    D,H
55              LD    D,L
DD 54           LD    D,IXH     2 Copia en D el valor del byte alto de IX.
DD 55           LD    D,IXL     2 Copia en D el valor del byte bajo de IX.
FD 54           LD    D,IYH     2 Copia en D el valor del byte alto de IY.
FD 55           LD    D,IYL     2 Copia en D el valor del byte bajo de IY.

5F              LD    E,A       1 Copia en E el valor del registro r.
58              LD    E,B
59              LD    E,C
5A              LD    E,D
5B              LD    E,E
5C              LD    E,H
5D              LD    E,L
DD 5C           LD    E,IXH     2 Copia en E el valor del byte alto de IX.
DD 5D           LD    E,IXL     2 Copia en E el valor del byte bajo de IX.
FD 5C           LD    E,IYH     2 Copia en E el valor del byte alto de IY.
FD 5D           LD    E,IYL     2 Copia en E el valor del byte bajo de IY.

67              LD    H,A       1 Copia en H el valor del registro r.
60              LD    H,B
61              LD    H,C
62              LD    H,D
63              LD    H,E
64              LD    H,H
65              LD    H,L

6F              LD    L,A       1 Copia en L el valor del registro r.
68              LD    L,B
69              LD    L,C
6A              LD    L,D
6B              LD    L,E
6C              LD    L,H
6D              LD    L,L

ED 47           LD    I,A       3 Copia en I el valor del acumulador.
ED 4F           LD    R,A       3 Copia en R el valor del acumulador.

3E hh           LD    A,n       2 Copia en el registro r el valor n.
06 hh           LD    B,n
0E hh           LD    C,n
16 hh           LD    D,n
1E hh           LD    E,n
26 hh           LD    H,n
2E hh           LD    L,n

7E              LD    A,(HL)    2 Copia en el registro r el valor en la ubicación de HL.
46              LD    B,(HL)
4E              LD    C,(HL)
56              LD    D,(HL)
66              LD    H,(HL)
6E              LD    L,(HL)

DD 7E hh        LD    A,(IX+d)  5 Copia en el registro r el valor en la ubicación de IX+d.
DD 46 hh        LD    B,(IX+d)
DD 4E hh        LD    C,(IX+d)
DD 56 hh        LD    D,(IX+d)
DD 5E hh        LD    E,(IX+d)
DD 66 hh        LD    H,(IX+d)
DD 6E hh        LD    L,(IX+d)
FD 7E hh        LD    A,(IY+d)  5 Copia en el registro r el valor en la ubicación de IY+d.
FD 46 hh        LD    B,(IY+d)
FD 4E hh        LD    C,(IY+d)
FD 56 hh        LD    D,(IY+d)
FD 5E hh        LD    E,(IY+d)
FD 66 hh        LD    H,(IY+d)
FD 6E hh        LD    L,(IY+d)

0A              LD    A,(BC)    2 Copia en el acumulador el valor en la ubicación de BC.
1A              LD    A,(DE)    2 Copia en el acumulador el valor en la ubicación de DE.
3A hh HH        LD    A,(HHhh)  4 Copia en el acumulador el valor en la ubicación HHhh.

F9              LD    SP,HL     2 Copia en SP el valor de HL.
DD F9           LD    SP,IX     3 Copia en SP el valor de IX.
FD F9           LD    SP,IY     3 Copia en SP el valor de IY.
31 hh HH        LD    SP,nn     3 Copia en SP el valor nn.
ED 7B hh HH     LD    SP,(HHhh) 6 Copia en SP el valor en la ubicación HHhh.

01 hh HH        LD    BC,nn     3 Copia en el registro doble rr el valor nn.
11 hh HH        LD    DE,nn
21 hh HH        LD    HL,nn
DD 21 hh HH     LD    IX,nn     4 Copia en IX el valor nn.
FD 21 hh HH     LD    IY,nn     4 Copia en IY el valor nn.

ED 4B hh HH     LD    BC,(HHhh) 6 Copia en el registro doble rr el valor en la ubicación HHhh.
ED 5B hh HH     LD    DE,(HHhh)
2A hh HH        LD    HL,(HHhh)
DD 2A hh HH     LD    IX,(HHhh) 6 Copia en IX el valor en la ubicación HHhh.
FD 2A hh HH     LD    IY,(HHhh) 6 Copia en IY el valor en la ubicación HHhh.

02              LD    (BC),A    2 Copia en la ubicación de rr el valor en r.
12              LD    (DE),A
77              LD    (HL),A
70              LD    (HL),B
71              LD    (HL),C
72              LD    (HL),D
73              LD    (HL),E
74              LD    (HL),H
75              LD    (HL),L
36 hh           LD    (HL),n    3 Copia en la ubicación de HL el valor n.
DD 36 dd nn     LD    (IX+d),n  6 Copia en la ubicación de IX+d el valor n.
DD 77 hh        LD    (IX+d),A  5 Copia en la ubicación de IX+d el valor del registro r.
DD 70 hh        LD    (IX+d),B
DD 71 hh        LD    (IX+d),C
DD 72 hh        LD    (IX+d),D
DD 73 hh        LD    (IX+d),E
DD 74 hh        LD    (IX+d),H
DD 75 hh        LD    (IX+d),L
FD 36 dd nn     LD    (IY+d),n  6 Copia en la ubicación de IY+d el valor n.
FD 77 hh        LD    (IY+d),A  5 Copia en la ubicación de IY+d el valor del registro r.
FD 70 hh        LD    (IY+d),B
FD 71 hh        LD    (IY+d),C
FD 72 hh        LD    (IY+d),D
FD 73 hh        LD    (IY+d),E
FD 74 hh        LD    (IY+d),H
FD 75 hh        LD    (IY+d),L

32 hh HH        LD    (HHhh),A  4 Copia en la ubicación HHhh el valor del acumulador.
22 hh HH        LD    (HHhh),HL 5 Copia en la ubicación HHhh el valor de HL.
ED 43 hh HH     LD    (HHhh),BC 6 Copia en la ubicación HHhh el valor del registro doble rr.
ED 53 hh HH     LD    (HHhh),DE
DD 22 hh HH     LD    (HHhh),IX
FD 22 hh HH     LD    (HHhh),IY
ED 73 hh HH     LD    (HHhh),SP

ED A8           LDD             5 Copia en (DE) el valor de la ubicación en HL, DE-1, HL-1, BC-1.
ED B8           LDDR          5/6 Repite LDD hasta que BC=0 (5), si BC&lt;&gt;0 (6).
ED A0           LDI             5 Copia en (DE) el valor de la ubicación en HL, DE+1, HL+1, BC-1.
ED B0           LDIR          5/6 Repite LDI hasta que BC=0 (5), si BC&lt;&gt;0 (6).

ED 44           NEG             2 Cambia el signo del acumulador (complemento a 2).
00              NOP             1 Operación vacía (No Operation).

B7              OR    A         1 OR lógico entre el registro r y el acumulador.
B0              OR    B
B1              OR    C
B2              OR    D
B3              OR    E
B4              OR    H
B5              OR    L
DD B4           OR    IXH       2 OR lógico entre el byte alto de IX y el acumulador.
DD B5           OR    IXL       2 OR lógico entre el byte bajo de IX y el acumulador.
FD B4           OR    IYH       2 OR lógico entre el byte alto de IY y el acumulador.
FD B5           OR    IYL       2 OR lógico entre el byte bajo de IY y el acumulador.
F6 hh           OR    n         2 OR lógico entre el valor n y el acumulador.
B6              OR    (HL)      2 OR lógico entre el valor en la ubicación de HL y A.
DD B6 hh        OR    (IX+d)    5 OR lógico entre el valor en la ubicación de IX+d y A.
FD B6 hh        OR    (IY+d)    5 OR lógico entre el valor en la ubicación de IY+d y A.
 
ED BB           OTDR          5/6 Repite OUTD hasta que B=0 (5), si B&lt;&gt;0 (6)[1].
ED B3           OTIR          5/6 Repite OTI hasta que B=0 (5), si B&lt;&gt;0 (6)[1].
ED 79           OUT   (C),A     4 Escribe en el puerto de salida almacenado en B el valor de r.
ED 49           OUT   (C),C       Revisar la nota [1] al final del listado.
ED 51           OUT   (C),D
ED 59           OUT   (C),E
ED 61           OUT   (C),H
ED 69           OUT   (C),L
D3 hh           OUT   (n),A     3 Escribe en el puerto de salida n el valor de A [1].
ED AB           OUTD            5 Escribe el valor de la ubicación de HL
                                en el puerto de salida indicado por B(!!), HL-1, B-1[1].
ED A3           OUTI            5 Escribe el valor de la ubicación de HL 
                                en el puerto de salida indicado por B(!!), HL+1, B-1[1].

F1              POP   AF        3 Copia en el registro doble rr el último valor de la pila.
C1              POP   BC
D1              POP   DE
E1              POP   HL
DD E1           POP   IX        5 Copia en IX el último valor de la pila.
FD E1           POP   IY        5 Copia en IY el último valor de la pila.

F5              PUSH  AF        4 Copia en la pila el valor del registro doble rr.
C5              PUSH  BC
D5              PUSH  DE
E5              PUSH  HL
DD E5           PUSH  IX        5 Copia en la pila el valor de IX.
FD E5           PUSH  IY        5 Copia en la pila el valor de IY.

CB **           RES   b,A       2 Pone a 0 el bit b del registro r.
CB **           RES   b,B         ** El último byte codifica el bit y el
CB **           RES   b,C            registro. Los valores empiezan en 80 y
CB **           RES   b,D            terminan en BF, el byte se compone como:
CB **           RES   b,E            1 0 b b b r r r
CB **           RES   b,H            b = [0-7]
CB **           RES   b,L            r = B=0, C, D, E, H, L, A=7
CB **           RES   b,(HL)    4 Pone a 0 el bit b del valor en la ubicación de HL.
DD CB hh **     RES   b,(IX+d)  7 Pone a 0 el bit b del valor en la ubicación de IX+d.
FD CB hh **     RES   b,(IY+d)  7 Pone a 0 el bit b del valor en la ubicación de IY+d.

C9              RET             3 Retorna de la subrutina.
C8              RET   z       2/4 Retorna de la subrutina si el flag Z es 1 (4) si no (2).
C0              RET   nz      2/4 Retorna de la subrutina si el flag Z es 0 (4) si no (2).
D8              RET   c       2/4 Retorna de la subrutina si el flag C es 1 (4) si no (2).
D0              RET   nc      2/4 Retorna de la subrutina si el flag C es 0 (4) si no (2).
F0              RET   p       2/4 Retorna de la subrutina si el flag S es 0 (4) si no (2).
F8              RET   m       2/4 Retorna de la subrutina si el flag S es 1 (4) si no (2).
E8              RET   pe      2/4 Retorna de la subrutina si el flag P/V es 1 (4) si no (2).
E0              RET   po      2/4 Retorna de la subrutina si el flag P/V es 0 (4) si no (2).

ED 4D           RETI            4 Retorna de la interrupción.
ED 45           RETN            4 Retorna de la interrupción no enmascarable.

CB 17           RL    A         2 Rota a la izquierda el valor del registro r
CB 10           RL    B           a través del flag C: el bit 7 se mueve al flag
CB 11           RL    C           de acarreo C y el valor actual de dicho flag
CB 12           RL    D           se mueve al bit 0.
CB 13           RL    E
CB 14           RL    H
CB 15           RL    L
CB 16           RL    (HL)      4 Rota a izq. el valor en la ubicación de HL. Usa flag C.
DD CB hh 16     RL    (IX+d)    7 Rota a izq. el valor en la ubicación de IX+d. Usa flag C.
FD CB hh 16     RL    (IY+d)    7 Rota a izq. el valor en la ubicación de IY+d. Usa flag C.

17              RLA             1 Rota a la izquierda el valor en A a través del flag C.

CB 07           RLC   A         2 Rota el valor de r a la izquierda de manera circular:
CB 00           RLC   B           el bit 7 se copia tanto al flag de acarreo C como
CB 01           RLC   C           al bit 0.
CB 02           RLC   D
CB 03           RLC   E
CB 04           RLC   H
CB 05           RLC   L
CB 06           RLC   (HL)      4 Rota el valor en (HL) a la izquierda de manera circular.
DD CB hh 06     RLC   (IX+d)    7 Rota el valor en (IX+d) a la izquierda de manera circular.
FD CB hh 06     RLC   (IY+d)    7 Rota el valor en (IY+d) a la izquierda de manera circular.

07              RLCA            1 Rota a la izquierda de manera circular el valor de A.
ED 6F           RLD             5 Rota a la izq. de forma circular cuatro bits (nibble):
                                nibble bajo A -&gt; nibble bajo (HL) -&gt; nibble alto (HL) -&gt;
                                nibble bajo A.

CB 1F           RR    A         2 Rota a la derecha el valor del registro r
CB 18           RR    B           a través del flag C: el bit 0 se mueve al flag
CB 19           RR    C           de acarreo C y el valor actual de dicho flag
CB 1A           RR    D           se mueve al bit 7.
CB 1B           RR    E
CB 1C           RR    H
CB 1D           RR    L
CB 1E           RR    (HL)      4 Rota a der. el valor en la ubicación de HL. Usa flag C.
DD CB hh 1E     RR    (IX+d)    7 Rota a der. el valor en la ubicación de IX+d. Usa flag C.
FD CB hh 1E     RR    (IY+d)    7 Rota a der. el valor en la ubicación de IY+d. Usa flag C.

1F              RRA             1 Rota a la derecha el valor de A a través del flag C.

CB 0F           RRC   A         2 Rota el valor de r a la derecha de manera circular:
CB 08           RRC   B           el bit 0 se copia tanto al flag de acarreo C como
CB 09           RRC   C           al bit 7.
CB 0A           RRC   D
CB 0B           RRC   E
CB 0C           RRC   H
CB 0D           RRC   L
CB 0E           RRC   (HL)      4 Rota el valor en (HL) a la der. de manera circular.
DD CB hh 0E     RRC   (IX+d)    7 Rota el valor en (IX+d) a la der. de manera circular.
FD CB hh 0E     RRC   (IY+d)    7 Rota el valor en (IY+d) a la der. de manera circular.

0F              RRCA            1 Rota el valor de A a la derecha de manera circular.
ED 67           RRD             5 Rota a la der. de forma circular cuatro bits (nibble):
                                nibble bajo A -&gt; nibble alto (HL) -&gt; nibble bajo (HL) -&gt;
                                nibble bajo A.

C7              RST   &amp;00       4 RESET. Reservado [2]. Reinicia el sistema.
CF              RST   &amp;08       4 LOW CALL. Reservado [2]. Salta a una rutina en los primeros 16K.
D7              RST   &amp;10       4 SIDE CALL. Reservado [2]. Llama a una rutina en una ROM.
DF              RST   &amp;18       4 FAR CALL. Reservado [2]. Llama a una rutina en cualquier pos de memoria.
E7              RST   &amp;20       4 RAM LAM. Reservado [2]. Lee el byte desde RAM en la dirección de HL.
EF              RST   &amp;28       4 FIRM JUMP. Reservado [2]. Salta a una rutina en el ROM inferior.
F7              RST   &amp;30       4 USER RST. Disponible para el usuario.
FF              RST   &amp;38       4 INTERRUPT. Reservado [2]. Reservado para interrupciones.

9F              SBC   A,A       1 Resta el registro r del acumulador con acarreo.
98              SBC   A,B
99              SBC   A,C
9A              SBC   A,D
9B              SBC   A,E
9C              SBC   A,H
9D              SBC   A,L
DD 9C           SBC   A,IXH     2 Resta el byte alto de IX del acumulador con acarreo.
DD 9D           SBC   A,IXL     2 Resta el byte bajo de IX del acumulador con acarreo.
FD 9C           SBC   A,IYH     2 Resta el byte alto de IY del acumulador con acarreo.
FD 9D           SBC   A,IYL     2 Resta el byte bajo de IY del acumulador con acarreo.
DE hh           SBC   A,n       2 Resta el valor n del acumulador con acarreo.
9E              SBC   A,(HL)    2 Resta el valor de la ubicación en HL de A con acarreo.
DD 9E hh        SBC   A,(IX+d)  5 Resta el valor de la ubicación en IX+d de A con acarreo.
FD 9E hh        SBC   A,(IY+d)  5 Resta el valor de la ubicación en IY+d de A con acarreo.
ED 42           SBC   HL,BC     4 Resta el registro doble rr de HL con acarreo.
ED 52           SBC   HL,DE
ED 62           SBC   HL,HL
ED 72           SBC   HL,SP

37              SCF             1 Establece el flag de acarreo (C=1).

CB **           SET   b,A       2 Establece a 1 el bit b del registro r.
CB **           SET   b,B         ** El último byte codifica el bit y el
CB **           SET   b,C            registro. La secuencia empieza en 80
CB **           SET   b,D            y termina en BF, el byte se compone como:
CB **           SET   b,E            1 1 b b b r r r
CB **           SET   b,H            b = [0-7]
CB **           SET   b,L            r = B=0, C, D, E, H, L, A=7
CB **           SET   b,(HL)    4 Establece a 1 el bit b del valor en ubicación de HL.
DD CB hh **     SET   b,(IX+d)  7 Establece a 1 el bit b del valor en ubicación de IX+d.
FD CB hh **     SET   b,(IY+d)  7 Establece a 1 el bit b del valor en ubicación de IY+d.

CB 27           SLA   A         2 Desplaza el registro r a la izquierda de manera aritmética.
CB 20           SLA   B           El valor del bit 7 se copia a flag de acarreo C.
CB 21           SLA   C           El valor del bit 0 se fija a 0.
CB 22           SLA   D
CB 23           SLA   E
CB 24           SLA   H
CB 25           SLA   L
CB 26           SLA   (HL)      4 Desplaza el valor en (HL) a la izq. Bit 0 = 0.
DD CB hh 26     SLA   (IX+d)    7 Desplaza el valor en (IX+d) a la izq. Bit 0 = 0.
FD CB hh 26     SLA   (IY+d)    7 Desplaza el valor en (IY+d) a la izq. Bit 0 = 0.

CB 37           SLL   A         2 Desplaza el registro r a la izquierda de forma &quot;lógica&quot;.
CB 30           SLL   B           El valor del bit 7 se copia en el flag de acarreo C.
CB 31           SLL   C           El valor del bit 0 se fija a 1.
CB 32           SLL   D
CB 33           SLL   E
CB 34           SLL   H
CB 35           SLL   L
CB 36           SLL   (HL)      4 Desplaza el valor en (HL) a la izquierda Bit 0 = 1.
DD CB hh 36     SLL   (IX+d)    7 Desplaza el valor en (IX+d) a la izquierda Bit 0 = 1.
FD CB hh 36     SLL   (IY+d)    7 Desplaza el valor en (IY+d) a la izquierda Bit 0 = 1.

CB 2F           SRA   A         2 Desplaza el valor de r a la derecha de forma aritmética.
CB 28           SRA   B           El valor del bit 0 se copia en el flag de acarreo C.
CB 29           SRA   C           El valor del bit 7 se fija a 0.
CB 2A           SRA   D
CB 2B           SRA   E
CB 2C           SRA   H
CB 2D           SRA   L
CB 2E           SRA   (HL)      4 Desplaza el valor en (HL) a la derecha. Bit 7 = 0.
DD CB hh 2E     SRA   (IX+d)    7 Desplaza el valor en (IX+d) a la derecha. Bit 7 = 0.
FD CB hh 2E     SRA   (IY+d)    7 Desplaza el valor en (IY+d) a la derecha. Bit 7 = 0.


CB 3F           SRL   A         2 Desplaza el registro r a la derecha de forma &quot;lógica&quot;.
CB 38           SRL   B           El bit 0 se copia al flag C (acarreo).
CB 39           SRL   C           El bit 7 se fija a 1.
CB 3A           SRL   D
CB 3B           SRL   E
CB 3C           SRL   H
CB 3D           SRL   L
CB 3E           SRL   (HL)      4 Desplaza el valor en (HL) a la derecha. Bit 7 = 1.
DD CB hh 3E     SRL   (IX+d)    7 Desplaza el valor en (IX+d) a la derecha. Bit 7 = 1.
FD CB hh 3E     SRL   (IY+d)    7 Desplaza el valor en (IY+d) a la derecha. Bit 7 = 1.

97              SUB   A         1 Resta el valor del registro r del acumulador.
90              SUB   B
91              SUB   C
92              SUB   D
93              SUB   E
94              SUB   H
95              SUB   L
D6 hh           SUB   n         2 Resta el valor n del acumulador.
DD 94           SUB   IXH       2 Resta el byte alto de IX del acumulador.
DD 95           SUB   IXL       2 Resta el byte bajo de IX del acumulador.
FD 94           SUB   IYH       2 Resta el byte alto de IY del acumulador.
FD 95           SUB   IYL       2 Resta el byte bajo de IY del acumulador.
96              SUB   (HL)      2 Resta el valor de la ubicación en HL del acumulador.
DD 96 hh        SUB   (IX+d)    5 Resta el valor de la ubicación en IX+d del acumulador.
FD 96 hh        SUB   (IY+d)    5 Resta el valor de la ubicación en IY+d del acumulador.

AF              XOR   A         1 Realiza una OR exclusiva entre el registro r y A.
A8              XOR   B
A9              XOR   C
AA              XOR   D
AB              XOR   E
AC              XOR   H
AD              XOR   L
EE hh           XOR   n         2 Realiza una OR exclusiva entre el valor n y A.
DD AC           XOR   IXH       2 Realiza una OR exclusiva entre el byte alto de IX y A.
DD AD           XOR   IXL       2 Realiza una OR exclusiva entre el byte bajo de IX y A.
FD AC           XOR   IYH       2 Realiza una OR exclusiva entre el byte alto de IY y A.
FD AD           XOR   IYL       2 Realiza una OR exclusiva entre el byte bajo de IY y A.
AE              XOR   (HL)      2 Realiza una OR exclusiva entre el valor en (HL) y A.
DD AE hh        XOR   (IX+d)    5 Realiza una OR exclusiva entre el valor en (IX+d) y A.
FD AE hh        XOR   (IY+d)    5 Realiza una OR exclusiva entre el valor en (IY+d) y A.</code></pre>
<p><strong>[1]</strong> Es importante recordar que las instrucciones de
la familia OUT/IN utilizan el contenido de <code>BC</code> y no solo
<code>C</code>, incluso si el código de operación es
<code>OUT (C)</code>. En el Amstrad CPC, las instrucciones OUTD, OUTI,
OTIR, etc., no tienen mucho sentido porque el AMSTRAD CPC utiliza el
valor de <code>B</code>(!!) del registro doble <code>BC</code> para
indicar el número del puerto y no <code>C</code>, como hacen muchas
otras máquinas basadas en el Z80.</p>
<p><strong>[2]</strong> Todas las instrucciones RST del Z80, excepto
una, han sido reservadas para uso del sistema. De RST 1 a RST 5
(&amp;08-&amp;28) se utilizan para extender el conjunto de instrucciones
añadiendo instrucciones específicas de llamada y salto que habilitan y
deshabilitan los ROMs. RST 6 (&amp;30) está disponible para el usuario.
Se puede obtener más información sobre el uso de la instrucción RST
aquí: <a href="https://www.cpcwiki.eu/imgs/f/f6/S968se02.pdf">ROMs. RAM
and Restart Instructions.</a></p>
<h1 id="historial-de-cambios">Historial de cambios</h1>
<ul>
<li>Versión 1.4.1 -
<ul>
<li>Pequeños arreglos en la biblioteca CPCTELERA</li>
<li>Mejores mensajes de error en las herramientas CDT/DSK</li>
</ul></li>
<li>Versión 1.4.0 - 07/01/2026
<ul>
<li>Añadida la directiva IFNOT</li>
<li>Añadida la herramienta <code>IMG</code></li>
</ul></li>
<li>Versión 1.3.1 - 28/12/2025
<ul>
<li>Los ejemplos de CPCTELERA no estaban funcionando desde el DSK.</li>
<li>Arreglo en los finales de línea de los ficheros ASCII añadidos a
ficheros DSK o CDT.</li>
<li>Se ha añadido un Make.sh en todos los ejemplos para su uso en Linux
o macOS.</li>
</ul></li>
<li>Versión 1.3.0 - 27/12/2025
<ul>
<li>Nueva directiva MDELETE para eliminar la definición de una
macro.</li>
<li>Arreglado un problema con el uso de macros sin parámetros.</li>
<li>Abasm muestra el mensaje de error adecuado si se usan las directivas
REPEAT o WHILE dentro de una macro.</li>
<li>Port de la biblioteca CPCTELERA como nuevo ejemplo de bibliotecas en
ABASM.</li>
<li>Nueva herramientas ASMPRJ para crear una estructura básica de
proyecto.</li>
</ul></li>
<li>Versión 1.2.0 - 15/12/2025
<ul>
<li>Soporte para el uso de bibliotecas, ficheros .asm situados dentro
del directorio <code>lib</code> de la distribución ABASM.</li>
<li>Port de parte de la biblioteca CPCRSLIB como ejemplo del nuevo
soporte a bibliotecas. Se pueden ver varios ejemplos de su uso en
<code>examples/cpcrslib</code>.</li>
<li>Nuevo flag <code>-s</code> <code>--sfile</code> que genera un único
fichero .s con todo el código ensamblado, incluyendo el código
importando de otros ficheros.</li>
<li>Mejora en la gestión de múltiples directivas ORG</li>
<li>Importa solo una vez un mismo fichero .ASM referenciado multiples
veces por READ o INCLUDE</li>
<li>Otras pequeñas mejoras.</li>
</ul></li>
<li>Version 1.1.3 - 16/04/2025
<ul>
<li>Se ha añadido la utilidad bindiff para comparar binarios.</li>
<li>Se ha corregido un error en la directiva ELSEIF.</li>
<li>Se ha añadido la opción <code>--tolerance</code> para poder suprimir
<em>warnings</em> o convertirlos en errores.</li>
<li>Otros pequeños arreglos y mejoras.</li>
</ul></li>
<li>Versión 1.1.2 - 26/03/2025
<ul>
<li>El listado de instrucciones del Z80 include ahora el código máquina
asociado.</li>
<li>Se han Arreglado las expresiones matemáticas con carácteres en la
directiva DB.</li>
<li>Otros pequeños arreglos y mejoras.</li>
</ul></li>
<li>Versión 1.1.1 - 09/03/2025
<ul>
<li>No se reconocía la familia de opcodes SLL.</li>
<li>EX AF,AF’ daba error.</li>
<li>Se ha añadido la sección
<code>Conjunto de Instrucciones del Z80</code> a los manuales.</li>
<li>Otros pequeños arreglos y mejoras.</li>
</ul></li>
<li>Versión 1.1.0 - 06/03/2025
<ul>
<li>Soporte para la directiva LIMIT.</li>
<li>Soporte de etiquetas locales dentro del código de las macros.</li>
<li>Añadido el flag –verbose como opción al ensamblador.</li>
<li>Añadidos tests ejecutables mediante python -m unittest</li>
<li>Otros pequeños arreglos y mejoras.</li>
</ul></li>
<li>Versión 1.0.0 - 03/10/2024
<ul>
<li>Primera versión liberada.</li>
</ul></li>
</ul>
</body>
</html>
